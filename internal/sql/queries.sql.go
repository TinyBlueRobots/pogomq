// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const completeMessage = `-- name: CompleteMessage :exec
UPDATE
  pogomq
SET
  completed = (NOW() AT TIME ZONE 'UTC'),
  ttl = CASE WHEN ttl_seconds IS NOT NULL THEN (NOW() AT TIME ZONE 'UTC') + (ttl_seconds * INTERVAL '1 second') ELSE NULL END
WHERE
  id = $1
  AND completed IS NULL
`

func (q *Queries) CompleteMessage(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, completeMessage, id)
	return err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM
  pogomq
WHERE
  id = $1
`

func (q *Queries) DeleteMessage(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteMessage, id)
	return err
}

type EnqueueMessagesParams struct {
	AutoComplete     bool
	Body             []byte
	ID               string
	MaxDeliveryCount int32
	Scheduled        pgtype.Timestamptz
	Topic            string
	Ttl              pgtype.Timestamptz
	TtlSeconds       pgtype.Int8
}

const failMessage = `-- name: FailMessage :exec
UPDATE
  pogomq
SET
  completed = NULL,
  scheduled = $1,
  ttl = CASE WHEN ttl_seconds IS NOT NULL THEN (NOW() AT TIME ZONE 'UTC') + (ttl_seconds * INTERVAL '1 second') ELSE NULL END
WHERE
  id = $2
  AND delivery_count < max_delivery_count
`

type FailMessageParams struct {
	Scheduled pgtype.Timestamptz
	ID        string
}

func (q *Queries) FailMessage(ctx context.Context, arg FailMessageParams) error {
	_, err := q.db.Exec(ctx, failMessage, arg.Scheduled, arg.ID)
	return err
}

const messageCounts = `-- name: MessageCounts :one
WITH message_counts AS (
  SELECT
    CASE
      WHEN completed IS NULL AND delivery_count < max_delivery_count AND scheduled <= (NOW() AT TIME ZONE 'UTC') THEN 'active'
      WHEN completed IS NULL AND delivery_count >= max_delivery_count THEN 'failed'
      WHEN completed IS NULL AND scheduled > (NOW() AT TIME ZONE 'UTC') THEN 'scheduled'
      WHEN completed IS NOT NULL THEN 'completed'
      ELSE 'unknown'
    END AS message_state
  FROM
    pogomq
  WHERE
    topic = $1
)
SELECT
  COALESCE(SUM(CASE WHEN message_state = 'active' THEN 1 ELSE 0 END), 0) :: INT AS active_count,
  COALESCE(SUM(CASE WHEN message_state = 'failed' THEN 1 ELSE 0 END), 0) :: INT AS failed_count,
  COALESCE(SUM(CASE WHEN message_state = 'scheduled' THEN 1 ELSE 0 END), 0) :: INT AS scheduled_count,
  COALESCE(SUM(CASE WHEN message_state = 'completed' THEN 1 ELSE 0 END), 0) :: INT AS completed_count
FROM
  message_counts
`

type MessageCountsRow struct {
	ActiveCount    int32
	FailedCount    int32
	ScheduledCount int32
	CompletedCount int32
}

func (q *Queries) MessageCounts(ctx context.Context, topic string) (MessageCountsRow, error) {
	row := q.db.QueryRow(ctx, messageCounts, topic)
	var i MessageCountsRow
	err := row.Scan(
		&i.ActiveCount,
		&i.FailedCount,
		&i.ScheduledCount,
		&i.CompletedCount,
	)
	return i, err
}

const purgeAllMessages = `-- name: PurgeAllMessages :exec
DELETE FROM
  pogomq
WHERE
  topic = $1
`

func (q *Queries) PurgeAllMessages(ctx context.Context, topic string) error {
	_, err := q.db.Exec(ctx, purgeAllMessages, topic)
	return err
}

const purgeCompletedMessages = `-- name: PurgeCompletedMessages :exec
DELETE FROM
  pogomq
WHERE
  completed IS NOT NULL
  AND topic = $1
`

func (q *Queries) PurgeCompletedMessages(ctx context.Context, topic string) error {
	_, err := q.db.Exec(ctx, purgeCompletedMessages, topic)
	return err
}

const purgeFailedMessages = `-- name: PurgeFailedMessages :exec
DELETE FROM
  pogomq
WHERE
  completed IS NULL
  AND delivery_count >= max_delivery_count
  AND topic = $1
`

func (q *Queries) PurgeFailedMessages(ctx context.Context, topic string) error {
	_, err := q.db.Exec(ctx, purgeFailedMessages, topic)
	return err
}

const purgeTTLMessages = `-- name: PurgeTTLMessages :exec
DELETE FROM
  pogomq
WHERE
  ttl IS NOT NULL
  AND ttl < (NOW() AT TIME ZONE 'UTC')
  AND topic = $1
`

func (q *Queries) PurgeTTLMessages(ctx context.Context, topic string) error {
	_, err := q.db.Exec(ctx, purgeTTLMessages, topic)
	return err
}

const readFailedMessages = `-- name: ReadFailedMessages :many
SELECT
  id,
  body,
  delivery_count,
  scheduled
FROM
  pogomq
WHERE
  topic = $2
  AND completed IS NULL
  AND delivery_count >= max_delivery_count
ORDER BY
  scheduled ASC
LIMIT $1
`

type ReadFailedMessagesParams struct {
	Limit int32
	Topic string
}

type ReadFailedMessagesRow struct {
	ID            string
	Body          []byte
	DeliveryCount int32
	Scheduled     pgtype.Timestamptz
}

func (q *Queries) ReadFailedMessages(ctx context.Context, arg ReadFailedMessagesParams) ([]ReadFailedMessagesRow, error) {
	rows, err := q.db.Query(ctx, readFailedMessages, arg.Limit, arg.Topic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadFailedMessagesRow
	for rows.Next() {
		var i ReadFailedMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Body,
			&i.DeliveryCount,
			&i.Scheduled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readMessages = `-- name: ReadMessages :many
WITH next_scheduled AS (
  SELECT MIN(scheduled) as next_time
  FROM pogomq
  WHERE 
    pogomq.topic = $2
    AND completed IS NULL
    AND scheduled > (NOW() AT TIME ZONE 'UTC')
    AND delivery_count < max_delivery_count
),
updates AS (
  UPDATE pogomq
  SET 
    delivery_count = delivery_count + 1,
    completed = CASE WHEN auto_complete THEN (NOW() AT TIME ZONE 'UTC') ELSE NULL END,
    ttl = CASE WHEN ttl_seconds IS NOT NULL THEN (NOW() AT TIME ZONE 'UTC') + (ttl_seconds * INTERVAL '1 second') ELSE NULL END
  WHERE
    ctid IN (
      SELECT ctid
      FROM pogomq
      WHERE 
        pogomq.topic = $2
        AND completed IS NULL
        AND scheduled <= (NOW() AT TIME ZONE 'UTC')
        AND delivery_count < max_delivery_count
      ORDER BY
        scheduled ASC
      FOR UPDATE SKIP LOCKED
      LIMIT $1
    )
  RETURNING 
    id, 
    body, 
    delivery_count,
    scheduled
)
SELECT 
  u.id, 
  u.body, 
  u.delivery_count,
  u.scheduled,
  (SELECT next_time FROM next_scheduled) :: TIMESTAMPTZ as next_time
FROM updates u
UNION ALL
SELECT 
  '' as id,
  NULL as body,
  0 as delivery_count,
  NULL as scheduled,
  (SELECT next_time FROM next_scheduled) :: TIMESTAMPTZ as next_time
WHERE NOT EXISTS (SELECT 1 FROM updates)
LIMIT $1
`

type ReadMessagesParams struct {
	Limit int32
	Topic string
}

type ReadMessagesRow struct {
	ID            string
	Body          []byte
	DeliveryCount int32
	Scheduled     pgtype.Timestamptz
	NextTime      pgtype.Timestamptz
}

func (q *Queries) ReadMessages(ctx context.Context, arg ReadMessagesParams) ([]ReadMessagesRow, error) {
	rows, err := q.db.Query(ctx, readMessages, arg.Limit, arg.Topic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadMessagesRow
	for rows.Next() {
		var i ReadMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Body,
			&i.DeliveryCount,
			&i.Scheduled,
			&i.NextTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetFailedMessage = `-- name: ResetFailedMessage :exec
UPDATE
  pogomq
SET
  completed = NULL,
  scheduled = (NOW() AT TIME ZONE 'UTC'),
  delivery_count = 0
WHERE
  id = $1
  AND topic = $2
  AND completed IS NOT NULL
`

type ResetFailedMessageParams struct {
	ID    string
	Topic string
}

func (q *Queries) ResetFailedMessage(ctx context.Context, arg ResetFailedMessageParams) error {
	_, err := q.db.Exec(ctx, resetFailedMessage, arg.ID, arg.Topic)
	return err
}

const resetFailedMessages = `-- name: ResetFailedMessages :exec
UPDATE
  pogomq
SET
  completed = NULL,
  scheduled = (NOW() AT TIME ZONE 'UTC'),
  delivery_count = 0
WHERE
  topic = $1
  AND completed IS NOT NULL
`

func (q *Queries) ResetFailedMessages(ctx context.Context, topic string) error {
	_, err := q.db.Exec(ctx, resetFailedMessages, topic)
	return err
}
